"""
This type stub file was generated by pyright.
"""

import sys
from typing import Any, Awaitable, Callable, Dict, Generic, Iterable, Iterator, List, Literal, NamedTuple, Optional, Set, TYPE_CHECKING, Tuple, Type, Union, overload
from _typeshed import SupportsRichComparisonT
from random import Random
from .parallel_mapping import ParallelMappingTransform
from .grouping import Grouping
from .list_like import ListLike
from functools import cached_property
from .transform import K, O as V, T, Transform, U

if __name__ == "__main__":
    __package__ = ...
if TYPE_CHECKING:
    ...
if sys.version_info < (3, 11):
    origin__namedtuple_mro_entries = ...
class Sequence(Generic[T], Iterable[T]):
    """
    Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]
    provided by that function.

    The values are evaluated lazily, and the sequence is potentially infinite.
    """
    __transform__: Transform[Any, T]
    def __init__(self, iterable: Union[Iterable[T], Transform[Any, T]]) -> None:
        ...
    
    @cached_property
    def transforms(self) -> Iterable[Transform[Any, Any]]:
        ...
    
    @property
    def data(self) -> List[T]:
        ...
    
    def dedup(self) -> Sequence[T]:
        """
        Removes consecutive repeated elements in the sequence.

        If the sequence is sorted, this removes all duplicates.

        Example 1:
        >>> lst = [ 'a1', 'a1', 'b2', 'a2', 'a1']
        >>> it(lst).dedup().to_list()
        ['a1', 'b2', 'a2', 'a1']

        Example 1:
        >>> lst = [ 'a1', 'a1', 'b2', 'a2', 'a1']
        >>> it(lst).sorted().dedup().to_list()
        ['a1', 'a2', 'b2']
        """
        ...
    
    @overload
    def dedup_by(self, key_selector: Callable[[T], Any]) -> Sequence[T]:
        ...
    
    @overload
    def dedup_by(self, key_selector: Callable[[T, int], Any]) -> Sequence[T]:
        ...
    
    @overload
    def dedup_by(self, key_selector: Callable[[T, int, Sequence[T]], Any]) -> Sequence[T]:
        ...
    
    def dedup_by(self, key_selector: Callable[..., Any]) -> Sequence[T]:
        """
        Removes all but the first of consecutive elements in the sequence that resolve to the same key.
        """
        ...
    
    @overload
    def dedup_with_count_by(self, key_selector: Callable[[T], Any]) -> Sequence[Tuple[T, int]]:
        ...
    
    @overload
    def dedup_with_count_by(self, key_selector: Callable[[T, int], Any]) -> Sequence[Tuple[T, int]]:
        ...
    
    @overload
    def dedup_with_count_by(self, key_selector: Callable[[T, int, Sequence[T]], Any]) -> Sequence[Tuple[T, int]]:
        ...
    
    def dedup_with_count_by(self, key_selector: Callable[..., Any]) -> Sequence[Tuple[T, int]]:
        """
        Removes all but the first of consecutive elements and its count that resolve to the same key.

        Example 1:
        >>> lst = [ 'a1', 'a1', 'b2', 'a2', 'a1']
        >>> it(lst).dedup_with_count_by(lambda x: x).to_list()
        [('a1', 2), ('b2', 1), ('a2', 1), ('a1', 1)]

        Example 1:
        >>> lst = [ 'a1', 'a1', 'b2', 'a2', 'a1']
        >>> it(lst).sorted().dedup_with_count_by(lambda x: x).to_list()
        [('a1', 3), ('a2', 1), ('b2', 1)]
        """
        ...
    
    @overload
    def dedup_into_group_by(self, key_selector: Callable[[T], Any]) -> Sequence[List[T]]:
        ...
    
    @overload
    def dedup_into_group_by(self, key_selector: Callable[[T, int], Any]) -> Sequence[List[T]]:
        ...
    
    @overload
    def dedup_into_group_by(self, key_selector: Callable[[T, int, Sequence[T]], Any]) -> Sequence[List[T]]:
        ...
    
    def dedup_into_group_by(self, key_selector: Callable[..., Any]) -> Sequence[List[T]]:
        ...
    
    @overload
    def filter(self, predicate: Callable[[T], bool]) -> Sequence[T]:
        ...
    
    @overload
    def filter(self, predicate: Callable[[T, int], bool]) -> Sequence[T]:
        ...
    
    @overload
    def filter(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Sequence[T]:
        ...
    
    def filter(self, predicate: Callable[..., bool]) -> Sequence[T]:
        """
        Returns a Sequence containing only elements matching the given [predicate].

        Example 1:
        >>> lst = [ 'a1', 'b1', 'b2', 'a2']
        >>> it(lst).filter(lambda x: x.startswith('a')).to_list()
        ['a1', 'a2']

        Example 2:
        >>> lst = [ 'a1', 'b1', 'b2', 'a2']
        >>> it(lst).filter(lambda x, i: x.startswith('a') or i % 2 == 0 ).to_list()
        ['a1', 'b2', 'a2']
        """
        ...
    
    def filter_is_instance(self, typ: Type[U]) -> Sequence[U]:
        """
        Returns a Sequence containing all elements that are instances of specified type parameter typ.

        Example 1:
        >>> lst = [ 'a1', 1, 'b2', 3]
        >>> it(lst).filter_is_instance(int).to_list()
        [1, 3]

        """
        ...
    
    @overload
    def filter_not(self, predicate: Callable[[T], bool]) -> Sequence[T]:
        ...
    
    @overload
    def filter_not(self, predicate: Callable[[T, int], bool]) -> Sequence[T]:
        ...
    
    @overload
    def filter_not(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Sequence[T]:
        ...
    
    def filter_not(self, predicate: Callable[..., bool]) -> Sequence[T]:
        """
        Returns a Sequence containing all elements not matching the given [predicate].

        Example 1:
        >>> lst = [ 'a1', 'b1', 'b2', 'a2']
        >>> it(lst).filter_not(lambda x: x.startswith('a')).to_list()
        ['b1', 'b2']

        Example 2:
        >>> lst = [ 'a1', 'a2', 'b1', 'b2']
        >>> it(lst).filter_not(lambda x, i: x.startswith('a') and i % 2 == 0 ).to_list()
        ['a2', 'b1', 'b2']
        """
        ...
    
    @overload
    def filter_not_none(self: Sequence[Optional[U]]) -> Sequence[U]:
        ...
    
    @overload
    def filter_not_none(self: Sequence[T]) -> Sequence[T]:
        ...
    
    def filter_not_none(self: Sequence[Optional[U]]) -> Sequence[U]:
        """
        Returns a Sequence containing all elements that are not `None`.

        Example 1:
        >>> lst = [ 'a', None, 'b']
        >>> it(lst).filter_not_none().to_list()
        ['a', 'b']
        """
        ...
    
    @overload
    def map(self, transform: Callable[[T], U]) -> Sequence[U]:
        ...
    
    @overload
    def map(self, transform: Callable[[T], U], return_exceptions: Literal[False]) -> Sequence[U]:
        ...
    
    @overload
    def map(self, transform: Callable[[T], U], return_exceptions: Literal[True]) -> Sequence[Union[U, BaseException]]:
        ...
    
    @overload
    def map(self, transform: Callable[[T, int], U]) -> Sequence[U]:
        ...
    
    @overload
    def map(self, transform: Callable[[T, int], U], return_exceptions: Literal[False]) -> Sequence[U]:
        ...
    
    @overload
    def map(self, transform: Callable[[T, int], U], return_exceptions: Literal[True]) -> Sequence[Union[U, BaseException]]:
        ...
    
    @overload
    def map(self, transform: Callable[[T, int, Sequence[T]], U]) -> Sequence[U]:
        ...
    
    @overload
    def map(self, transform: Callable[[T, int, Sequence[T]], U], return_exceptions: Literal[False]) -> Sequence[U]:
        ...
    
    @overload
    def map(self, transform: Callable[[T, int, Sequence[T]], U], return_exceptions: Literal[True]) -> Sequence[Union[U, BaseException]]:
        ...
    
    def map(self, transform: Callable[..., U], return_exceptions: bool = ...) -> Union[Sequence[U], Sequence[Union[U, BaseException]]]:
        """
        Returns a Sequence containing the results of applying the given [transform] function
        to each element in the original Sequence.

        Example 1:
        >>> lst = [{ 'name': 'A', 'age': 12}, { 'name': 'B', 'age': 13}]
        >>> it(lst).map(lambda x: x['age']).to_list()
        [12, 13]

        Example 2:
        >>> lst = [{ 'name': 'A', 'age': 12}, { 'name': 'B', 'age': 13}]
        >>> it(lst).map(lambda x, i: x['name'] + str(i)).to_list()
        ['A0', 'B1']

        Example 3:
        >>> lst = ['hi', 'abc']
        >>> it(lst).map(len).to_list()
        [2, 3]
        """
        ...
    
    @overload
    async def map_async(self, transform: Callable[[T], Awaitable[U]]) -> Sequence[U]:
        ...
    
    @overload
    async def map_async(self, transform: Callable[[T, int], Awaitable[U]], return_exceptions: Literal[True]) -> Sequence[Union[U, BaseException]]:
        ...
    
    @overload
    async def map_async(self, transform: Callable[[T, int, Sequence[T]], Awaitable[U]], return_exceptions: Literal[False] = ...) -> Sequence[U]:
        ...
    
    async def map_async(self, transform: Callable[..., Awaitable[U]], return_exceptions: bool = ...) -> Union[Sequence[U], Sequence[Union[U, BaseException]]]:
        """
        Similar to `.map()` but you can input a async transform then await it.
        """
        ...
    
    @overload
    def map_not_none(self, transform: Callable[[T], Optional[U]]) -> Sequence[U]:
        ...
    
    @overload
    def map_not_none(self, transform: Callable[[T, int], Optional[U]]) -> Sequence[U]:
        ...
    
    @overload
    def map_not_none(self, transform: Callable[[T, int, Sequence[T]], Optional[U]]) -> Sequence[U]:
        ...
    
    def map_not_none(self, transform: Callable[..., Optional[U]]) -> Sequence[U]:
        """
        Returns a Sequence containing only the non-none results of applying the given [transform] function
        to each element in the original collection.

        Example 1:
        >>> lst = [{ 'name': 'A', 'age': 12}, { 'name': 'B', 'age': None}]
        >>> it(lst).map_not_none(lambda x: x['age']).to_list()
        [12]
        """
        ...
    
    @overload
    def parallel_map(self, transform: Callable[[T], U], max_workers: Optional[int] = ..., chunksize: int = ..., executor: ParallelMappingTransform.Executor = ...) -> Sequence[U]:
        ...
    
    @overload
    def parallel_map(self, transform: Callable[[T, int], U], max_workers: Optional[int] = ..., chunksize: int = ..., executor: ParallelMappingTransform.Executor = ...) -> Sequence[U]:
        ...
    
    @overload
    def parallel_map(self, transform: Callable[[T, int, Sequence[T]], U], max_workers: Optional[int] = ..., chunksize: int = ..., executor: ParallelMappingTransform.Executor = ...) -> Sequence[U]:
        ...
    
    def parallel_map(self, transform: Callable[..., U], max_workers: Optional[int] = ..., chunksize: int = ..., executor: ParallelMappingTransform.Executor = ...) -> Sequence[U]:
        """
        Returns a Sequence containing the results of applying the given [transform] function
        to each element in the original Sequence.

        Example 1:
        >>> lst = [{ 'name': 'A', 'age': 12}, { 'name': 'B', 'age': 13}]
        >>> it(lst).parallel_map(lambda x: x['age']).to_list()
        [12, 13]

        Example 2:
        >>> lst = [{ 'name': 'A', 'age': 12}, { 'name': 'B', 'age': 13}]
        >>> it(lst).parallel_map(lambda x: x['age'], max_workers=2).to_list()
        [12, 13]

        Example 3:
        >>> lst = [{ 'name': 'A', 'age': 12}, { 'name': 'B', 'age': 13}]
        >>> it(lst).parallel_map(lambda x, i: x['age'] + i, max_workers=2).to_list()
        [12, 14]
        """
        ...
    
    @overload
    def find(self, predicate: Callable[[T], bool]) -> Optional[T]:
        ...
    
    @overload
    def find(self, predicate: Callable[[T, int], bool]) -> Optional[T]:
        ...
    
    @overload
    def find(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Optional[T]:
        ...
    
    def find(self, predicate: Callable[..., bool]) -> Optional[T]:
        """
        Returns the first element matching the given [predicate], or `None` if no such element was found.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).find(lambda x: x == 'b')
        'b'
        """
        ...
    
    def find_last(self, predicate: Callable[[T], bool]) -> Optional[T]:
        """
        Returns the last element matching the given [predicate], or `None` if no such element was found.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).find_last(lambda x: x == 'b')
        'b'
        """
        ...
    
    @overload
    def first(self) -> T:
        ...
    
    @overload
    def first(self, predicate: Callable[[T], bool]) -> T:
        ...
    
    @overload
    def first(self, predicate: Callable[[T, int], bool]) -> T:
        ...
    
    @overload
    def first(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> T:
        ...
    
    def first(self, predicate: Optional[Callable[..., bool]] = ...) -> T:
        """
        Returns first element.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).first()
        'a'

        Example 2:
        >>> lst = []
        >>> it(lst).first()
        Traceback (most recent call last):
        ...
        ValueError: Sequence is empty.

        Example 3:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).first(lambda x: x == 'b')
        'b'

        Example 4:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).first(lambda x: x == 'd')
        Traceback (most recent call last):
        ...
        ValueError: Sequence is empty.

        Example 5:
        >>> lst = [None]
        >>> it(lst).first() is None
        True
        """
        ...
    
    @overload
    def first_not_none_of(self: Sequence[Optional[U]]) -> U:
        ...
    
    @overload
    def first_not_none_of(self: Sequence[Optional[U]], transform: Callable[[Optional[U]], Optional[U]]) -> U:
        ...
    
    @overload
    def first_not_none_of(self: Sequence[Optional[U]], transform: Callable[[Optional[U], int], Optional[U]]) -> U:
        ...
    
    @overload
    def first_not_none_of(self: Sequence[Optional[U]], transform: Callable[[Optional[U], int, Sequence[Optional[U]]], Optional[U]]) -> U:
        ...
    
    def first_not_none_of(self: Sequence[Optional[U]], transform: Optional[Callable[..., Optional[U]]] = ...) -> U:
        """
        Returns the first non-`None` result of applying the given [transform] function to each element in the original collection.

        Example 1:
        >>> lst = [{ 'name': 'A', 'age': None}, { 'name': 'B', 'age': 12}]
        >>> it(lst).first_not_none_of(lambda x: x['age'])
        12

        Example 2:
        >>> lst = [{ 'name': 'A', 'age': None}, { 'name': 'B', 'age': None}]
        >>> it(lst).first_not_none_of(lambda x: x['age'])
        Traceback (most recent call last):
        ...
        ValueError: No element of the Sequence was transformed to a non-none value.
        """
        ...
    
    @overload
    def first_not_none_of_or_none(self) -> Optional[T]:
        ...
    
    @overload
    def first_not_none_of_or_none(self, transform: Callable[[T], T]) -> Optional[T]:
        ...
    
    @overload
    def first_not_none_of_or_none(self, transform: Callable[[T, int], T]) -> Optional[T]:
        ...
    
    @overload
    def first_not_none_of_or_none(self, transform: Callable[[T, int, Sequence[T]], T]) -> Optional[T]:
        ...
    
    def first_not_none_of_or_none(self, transform: Optional[Callable[..., T]] = ...) -> Optional[T]:
        """
        Returns the first non-`None` result of applying the given [transform] function to each element in the original collection.

        Example 1:
        >>> lst = [{ 'name': 'A', 'age': None}, { 'name': 'B', 'age': 12}]
        >>> it(lst).first_not_none_of_or_none(lambda x: x['age'])
        12

        Example 2:
        >>> lst = [{ 'name': 'A', 'age': None}, { 'name': 'B', 'age': None}]
        >>> it(lst).first_not_none_of_or_none(lambda x: x['age']) is None
        True
        """
        ...
    
    @overload
    def first_or_none(self) -> Optional[T]:
        ...
    
    @overload
    def first_or_none(self, predicate: Callable[[T], bool]) -> Optional[T]:
        ...
    
    @overload
    def first_or_none(self, predicate: Callable[[T, int], bool]) -> Optional[T]:
        ...
    
    @overload
    def first_or_none(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Optional[T]:
        ...
    
    def first_or_none(self, predicate: Optional[Callable[..., bool]] = ...) -> Optional[T]:
        """
        Returns the first element, or `None` if the Sequence is empty.

        Example 1:
        >>> lst = []
        >>> it(lst).first_or_none() is None
        True

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).first_or_none()
        'a'

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).first_or_none(lambda x: x == 'b')
        'b'
        """
        ...
    
    @overload
    def first_or_default(self, default: U) -> Union[T, U]:
        ...
    
    @overload
    def first_or_default(self, predicate: Callable[[T], bool], default: U) -> Union[T, U]:
        ...
    
    @overload
    def first_or_default(self, predicate: Callable[[T, int], bool], default: U) -> Union[T, U]:
        ...
    
    @overload
    def first_or_default(self, predicate: Callable[[T, int, Sequence[T]], bool], default: U) -> Union[T, U]:
        ...
    
    def first_or_default(self, predicate: Union[Callable[..., bool], U], default: Optional[U] = ...) -> Union[T, U, None]:
        """
        Returns the first element, or the given [default] if the Sequence is empty.

        Example 1:
        >>> lst = []
        >>> it(lst).first_or_default('a')
        'a'

        Example 2:
        >>> lst = ['b']
        >>> it(lst).first_or_default('a')
        'b'

        Example 3:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).first_or_default(lambda x: x == 'b', 'd')
        'b'

        Example 4:
        >>> lst = []
        >>> it(lst).first_or_default(lambda x: x == 'b', 'd')
        'd'
        """
        ...
    
    @overload
    def last(self) -> T:
        ...
    
    @overload
    def last(self, predicate: Callable[[T], bool]) -> T:
        ...
    
    @overload
    def last(self, predicate: Callable[[T, int], bool]) -> T:
        ...
    
    @overload
    def last(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> T:
        ...
    
    def last(self, predicate: Optional[Callable[..., bool]] = ...) -> T:
        """
        Returns last element.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).last()
        'c'

        Example 2:
        >>> lst = []
        >>> it(lst).last()
        Traceback (most recent call last):
        ...
        ValueError: Sequence is empty.
        """
        ...
    
    @overload
    def last_or_none(self) -> Optional[T]:
        ...
    
    @overload
    def last_or_none(self, predicate: Callable[[T], bool]) -> Optional[T]:
        ...
    
    @overload
    def last_or_none(self, predicate: Callable[[T, int], bool]) -> Optional[T]:
        ...
    
    @overload
    def last_or_none(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Optional[T]:
        ...
    
    def last_or_none(self, predicate: Optional[Callable[..., bool]] = ...) -> Optional[T]:
        """
        Returns the last element matching the given [predicate], or `None` if no such element was found.

        Exmaple 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).last_or_none()
        'c'

        Exmaple 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).last_or_none(lambda x: x != 'c')
        'b'

        Exmaple 3:
        >>> lst = []
        >>> it(lst).last_or_none(lambda x: x != 'c') is None
        True
        """
        ...
    
    def index_of_or_none(self, element: T) -> Optional[int]:
        """
        Returns first index of [element], or None if the collection does not contain element.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_or_none('b')
        1

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_or_none('d')
        """
        ...
    
    def index_of(self, element: T) -> int:
        """
        Returns first index of [element], or -1 if the collection does not contain element.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of('b')
        1

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of('d')
        -1
        """
        ...
    
    def index_of_or(self, element: T, default: int) -> int:
        """
        Returns first index of [element], or default value if the collection does not contain element.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_or('b', 1)
        1

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_or('d', 0)
        0
        """
        ...
    
    def index_of_or_else(self, element: T, f: Callable[[], int]) -> int:
        """
        Returns first index of [element], or computes the value from a callback if the collection does not contain element.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_or_else('b', lambda: 2)
        1

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_or_else('d', lambda: 0)
        0
        """
        ...
    
    def last_index_of_or_none(self, element: T) -> Optional[int]:
        """
         Returns last index of [element], or None if the collection does not contain element.

        Example 1:
        >>> lst = ['a', 'b', 'c', 'b']
        >>> it(lst).last_index_of_or_none('b')
        3

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).last_index_of_or_none('d')
        """
        ...
    
    def last_index_of(self, element: T) -> int:
        """
         Returns last index of [element], or -1 if the collection does not contain element.

        Example 1:
        >>> lst = ['a', 'b', 'c', 'b']
        >>> it(lst).last_index_of('b')
        3

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).last_index_of('d')
        -1
        """
        ...
    
    def last_index_of_or(self, element: T, default: int) -> int:
        """
         Returns last index of [element], or default value if the collection does not contain element.

        Example 1:
        >>> lst = ['a', 'b', 'c', 'b']
        >>> it(lst).last_index_of_or('b', 0)
        3

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).last_index_of_or('d', len(lst))
        3
        """
        ...
    
    def last_index_of_or_else(self, element: T, f: Callable[[], int]) -> int:
        """
         Returns last index of [element], or computes the value from a callback if the collection does not contain element.

        Example 1:
        >>> lst = ['a', 'b', 'c', 'b']
        >>> it(lst).last_index_of_or_else('b', lambda: 0)
        3

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).last_index_of_or_else('d', lambda: len(lst))
        3
        """
        ...
    
    @overload
    def index_of_first_or_none(self, predicate: Callable[[T], bool]) -> Optional[int]:
        ...
    
    @overload
    def index_of_first_or_none(self, predicate: Callable[[T, int], bool]) -> Optional[int]:
        ...
    
    @overload
    def index_of_first_or_none(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Optional[int]:
        ...
    
    def index_of_first_or_none(self, predicate: Callable[..., bool]) -> Optional[int]:
        """
        Returns first index of element matching the given [predicate], or None if no such element was found.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first_or_none(lambda x: x == 'b')
        1

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first_or_none(lambda x: x == 'd')
        """
        ...
    
    @overload
    def index_of_first(self, predicate: Callable[[T], bool]) -> int:
        ...
    
    @overload
    def index_of_first(self, predicate: Callable[[T, int], bool]) -> int:
        ...
    
    @overload
    def index_of_first(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> int:
        ...
    
    def index_of_first(self, predicate: Callable[..., bool]) -> int:
        """
        Returns first index of element matching the given [predicate], or -1 if no such element was found.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first(lambda x: x == 'b')
        1

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first(lambda x: x == 'd')
        -1

        Example 3:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first(lambda x: x == 'a')
        0
        """
        ...
    
    @overload
    def index_of_first_or(self, predicate: Callable[[T], bool], default: int) -> int:
        ...
    
    @overload
    def index_of_first_or(self, predicate: Callable[[T, int], bool], default: int) -> int:
        ...
    
    @overload
    def index_of_first_or(self, predicate: Callable[[T, int, Sequence[T]], bool], default: int) -> int:
        ...
    
    def index_of_first_or(self, predicate: Callable[..., bool], default: int) -> int:
        """
        Returns first index of element matching the given [predicate], or default value if no such element was found.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first_or(lambda x: x == 'b', 0)
        1

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first_or(lambda x: x == 'd', 0)
        0

        Example 3:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first_or(lambda x: x == 'a', 0)
        0
        """
        ...
    
    @overload
    def index_of_first_or_else(self, predicate: Callable[[T], bool], f: Callable[[], int]) -> int:
        ...
    
    @overload
    def index_of_first_or_else(self, predicate: Callable[[T, int], bool], f: Callable[[], int]) -> int:
        ...
    
    @overload
    def index_of_first_or_else(self, predicate: Callable[[T, int, Sequence[T]], bool], f: Callable[[], int]) -> int:
        ...
    
    def index_of_first_or_else(self, predicate: Callable[..., bool], f: Callable[[], int]) -> int:
        """
        Returns first index of element matching the given [predicate], or computes the value from a callback if no such element was found.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first_or_else(lambda x: x == 'b', lambda: len(lst))
        1

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first_or_else(lambda x: x == 'd', lambda: len(lst))
        3

        Example 3:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_first_or_else(lambda x: x == 'a', lambda: len(lst))
        0
        """
        ...
    
    @overload
    def index_of_last_or_none(self, predicate: Callable[[T], bool]) -> Optional[int]:
        ...
    
    @overload
    def index_of_last_or_none(self, predicate: Callable[[T, int], bool]) -> Optional[int]:
        ...
    
    @overload
    def index_of_last_or_none(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Optional[int]:
        ...
    
    def index_of_last_or_none(self, predicate: Callable[..., bool]) -> Optional[int]:
        """
        Returns last index of element matching the given [predicate], or -1 if no such element was found.

        Example 1:
        >>> lst = ['a', 'b', 'c', 'b']
        >>> it(lst).index_of_last_or_none(lambda x: x == 'b')
        3

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_last_or_none(lambda x: x == 'd')
        """
        ...
    
    @overload
    def index_of_last(self, predicate: Callable[[T], bool]) -> int:
        ...
    
    @overload
    def index_of_last(self, predicate: Callable[[T, int], bool]) -> int:
        ...
    
    @overload
    def index_of_last(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> int:
        ...
    
    def index_of_last(self, predicate: Callable[..., bool]) -> int:
        """
        Returns last index of element matching the given [predicate], or -1 if no such element was found.

        Example 1:
        >>> lst = ['a', 'b', 'c', 'b']
        >>> it(lst).index_of_last(lambda x: x == 'b')
        3

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_last(lambda x: x == 'd')
        -1

        Example 3:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_last(lambda x: x == 'a')
        0
        """
        ...
    
    @overload
    def index_of_last_or(self, predicate: Callable[[T], bool], default: int) -> int:
        ...
    
    @overload
    def index_of_last_or(self, predicate: Callable[[T, int], bool], default: int) -> int:
        ...
    
    @overload
    def index_of_last_or(self, predicate: Callable[[T, int, Sequence[T]], bool], default: int) -> int:
        ...
    
    def index_of_last_or(self, predicate: Callable[..., bool], default: int) -> int:
        """
        Returns last index of element matching the given [predicate], or default value if no such element was found.

        Example 1:
        >>> lst = ['a', 'b', 'c', 'b']
        >>> it(lst).index_of_last_or(lambda x: x == 'b', 0)
        3

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_last_or(lambda x: x == 'd', -99)
        -99

        Example 3:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_last_or(lambda x: x == 'a', 0)
        0
        """
        ...
    
    @overload
    def index_of_last_o_else(self, predicate: Callable[[T], bool], f: Callable[[], int]) -> int:
        ...
    
    @overload
    def index_of_last_o_else(self, predicate: Callable[[T, int], bool], f: Callable[[], int]) -> int:
        ...
    
    @overload
    def index_of_last_o_else(self, predicate: Callable[[T, int, Sequence[T]], bool], f: Callable[[], int]) -> int:
        ...
    
    def index_of_last_o_else(self, predicate: Callable[..., bool], f: Callable[[], int]) -> int:
        """
        Returns last index of element matching the given [predicate], or default value if no such element was found.

        Example 1:
        >>> lst = ['a', 'b', 'c', 'b']
        >>> it(lst).index_of_last_o_else(lambda x: x == 'b', lambda: -len(lst))
        3

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_last_o_else(lambda x: x == 'd', lambda: -len(lst))
        -3

        Example 3:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).index_of_last_o_else(lambda x: x == 'a', lambda: -len(lst))
        0
        """
        ...
    
    @overload
    def single(self) -> T:
        ...
    
    @overload
    def single(self, predicate: Callable[[T], bool]) -> T:
        ...
    
    @overload
    def single(self, predicate: Callable[[T, int], bool]) -> T:
        ...
    
    @overload
    def single(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> T:
        ...
    
    def single(self, predicate: Optional[Callable[..., bool]] = ...) -> T:
        """
        Returns the single element matching the given [predicate], or throws exception if there is no
        or more than one matching element.

        Exmaple 1:
        >>> lst = ['a']
        >>> it(lst).single()
        'a'

        Exmaple 2:
        >>> lst = []
        >>> it(lst).single() is None
        Traceback (most recent call last):
        ...
        ValueError: Sequence contains no element matching the predicate.

        Exmaple 2:
        >>> lst = ['a', 'b']
        >>> it(lst).single() is None
        Traceback (most recent call last):
        ...
        ValueError: Sequence contains more than one matching element.
        """
        ...
    
    @overload
    def single_or_none(self) -> Optional[T]:
        ...
    
    @overload
    def single_or_none(self, predicate: Callable[[T], bool]) -> Optional[T]:
        ...
    
    @overload
    def single_or_none(self, predicate: Callable[[T, int], bool]) -> Optional[T]:
        ...
    
    @overload
    def single_or_none(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Optional[T]:
        ...
    
    def single_or_none(self, predicate: Optional[Callable[..., bool]] = ...) -> Optional[T]:
        """
        Returns the single element matching the given [predicate], or `None` if element was not found
        or more than one element was found.

        Exmaple 1:
        >>> lst = ['a']
        >>> it(lst).single_or_none()
        'a'

        Exmaple 2:
        >>> lst = []
        >>> it(lst).single_or_none()

        Exmaple 2:
        >>> lst = ['a', 'b']
        >>> it(lst).single_or_none()

        """
        ...
    
    def drop(self, n: int) -> Sequence[T]:
        """
        Returns a Sequence containing all elements except first [n] elements.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).drop(0).to_list()
        ['a', 'b', 'c']

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).drop(1).to_list()
        ['b', 'c']

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).drop(4).to_list()
        []
        """
        ...
    
    @overload
    def drop_while(self, predicate: Callable[[T], bool]) -> Sequence[T]:
        ...
    
    @overload
    def drop_while(self, predicate: Callable[[T, int], bool]) -> Sequence[T]:
        ...
    
    @overload
    def drop_while(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Sequence[T]:
        ...
    
    def drop_while(self, predicate: Callable[..., bool]) -> Sequence[T]:
        """
        Returns a Sequence containing all elements except first elements that satisfy the given [predicate].

        Example 1:
        >>> lst = [1, 2, 3, 4, 1]
        >>> it(lst).drop_while(lambda x: x < 3 ).to_list()
        [3, 4, 1]
        """
        ...
    
    def skip(self, n: int) -> Sequence[T]:
        """
        Returns a Sequence containing all elements except first [n] elements.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).skip(0).to_list()
        ['a', 'b', 'c']

         Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).skip(1).to_list()
        ['b', 'c']

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).skip(4).to_list()
        []
        """
        ...
    
    @overload
    def skip_while(self, predicate: Callable[[T], bool]) -> Sequence[T]:
        ...
    
    @overload
    def skip_while(self, predicate: Callable[[T, int], bool]) -> Sequence[T]:
        ...
    
    @overload
    def skip_while(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Sequence[T]:
        ...
    
    def skip_while(self, predicate: Callable[..., bool]) -> Sequence[T]:
        """
        Returns a Sequence containing all elements except first elements that satisfy the given [predicate].

        Example 1:
        >>> lst = [1, 2, 3, 4, 1]
        >>> it(lst).skip_while(lambda x: x < 3 ).to_list()
        [3, 4, 1]
        """
        ...
    
    def take(self, n: int) -> Sequence[T]:
        """
        Returns an Sequence containing first [n] elements.

        Example 1:
        >>> a = ['a', 'b', 'c']
        >>> it(a).take(0).to_list()
        []

        Example 2:
        >>> a = ['a', 'b', 'c']
        >>> it(a).take(2).to_list()
        ['a', 'b']
        """
        ...
    
    @overload
    def take_while(self, predicate: Callable[[T], bool]) -> Sequence[T]:
        ...
    
    @overload
    def take_while(self, predicate: Callable[[T, int], bool]) -> Sequence[T]:
        ...
    
    @overload
    def take_while(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Sequence[T]:
        ...
    
    def take_while(self, predicate: Callable[..., bool]) -> Sequence[T]:
        """
        Returns an Sequence containing first elements satisfying the given [predicate].

        Example 1:
        >>> lst = ['a', 'b', 'c', 'd']
        >>> it(lst).take_while(lambda x: x in ['a', 'b']).to_list()
        ['a', 'b']
        """
        ...
    
    def take_last(self, n: int) -> Sequence[T]:
        """
        Returns an Sequence containing last [n] elements.

        Example 1:
        >>> a = ['a', 'b', 'c']
        >>> it(a).take_last(0).to_list()
        []

        Example 2:
        >>> a = ['a', 'b', 'c']
        >>> it(a).take_last(2).to_list()
        ['b', 'c']
        """
        ...
    
    def sorted(self) -> Sequence[T]:
        """
        Returns an Sequence that yields elements of this Sequence sorted according to their natural sort order.

        Example 1:
        >>> lst = ['b', 'a', 'e', 'c']
        >>> it(lst).sorted().to_list()
        ['a', 'b', 'c', 'e']

         Example 2:
        >>> lst = [2, 1, 4, 3]
        >>> it(lst).sorted().to_list()
        [1, 2, 3, 4]
        """
        ...
    
    @overload
    def sorted_by(self, key_selector: Callable[[T], SupportsRichComparisonT]) -> Sequence[T]:
        ...
    
    @overload
    def sorted_by(self, key_selector: Callable[[T, int], SupportsRichComparisonT]) -> Sequence[T]:
        ...
    
    @overload
    def sorted_by(self, key_selector: Callable[[T, int, Sequence[T]], SupportsRichComparisonT]) -> Sequence[T]:
        ...
    
    def sorted_by(self, key_selector: Callable[..., SupportsRichComparisonT]) -> Sequence[T]:
        """
        Returns a sequence that yields elements of this sequence sorted according to natural sort
        order of the value returned by specified [key_selector] function.

        Example 1:
        >>> lst = [ {'name': 'A', 'age': 12 }, {'name': 'C', 'age': 10 }, {'name': 'B', 'age': 11 } ]
        >>> it(lst).sorted_by(lambda x: x['name']).to_list()
        [{'name': 'A', 'age': 12}, {'name': 'B', 'age': 11}, {'name': 'C', 'age': 10}]
        >>> it(lst).sorted_by(lambda x: x['age']).to_list()
        [{'name': 'C', 'age': 10}, {'name': 'B', 'age': 11}, {'name': 'A', 'age': 12}]
        """
        ...
    
    def sorted_descending(self) -> Sequence[T]:
        """
        Returns a Sequence of all elements sorted descending according to their natural sort order.

        Example 1:
        >>> lst = ['b', 'c', 'a']
        >>> it(lst).sorted_descending().to_list()
        ['c', 'b', 'a']
        """
        ...
    
    @overload
    def sorted_by_descending(self, key_selector: Callable[[T], SupportsRichComparisonT]) -> Sequence[T]:
        ...
    
    @overload
    def sorted_by_descending(self, key_selector: Callable[[T, int], SupportsRichComparisonT]) -> Sequence[T]:
        ...
    
    @overload
    def sorted_by_descending(self, key_selector: Callable[[T, int, Sequence[T]], SupportsRichComparisonT]) -> Sequence[T]:
        ...
    
    def sorted_by_descending(self, key_selector: Callable[..., SupportsRichComparisonT]) -> Sequence[T]:
        """
        Returns a sequence that yields elements of this sequence sorted descending according
        to natural sort order of the value returned by specified [key_selector] function.

        Example 1:
        >>> lst = [ {'name': 'A', 'age': 12 }, {'name': 'C', 'age': 10 }, {'name': 'B', 'age': 11 } ]
        >>> it(lst).sorted_by_descending(lambda x: x['name']).to_list()
        [{'name': 'C', 'age': 10}, {'name': 'B', 'age': 11}, {'name': 'A', 'age': 12}]
        >>> it(lst).sorted_by_descending(lambda x: x['age']).to_list()
        [{'name': 'A', 'age': 12}, {'name': 'B', 'age': 11}, {'name': 'C', 'age': 10}]
        """
        ...
    
    def sorted_with(self, comparator: Callable[[T, T], int]) -> Sequence[T]:
        """
        Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].

        Example 1:
        >>> lst = ['aa', 'bbb', 'c']
        >>> it(lst).sorted_with(lambda a, b: len(a)-len(b)).to_list()
        ['c', 'aa', 'bbb']
        """
        ...
    
    @overload
    def associate(self, transform: Callable[[T], Tuple[K, V]]) -> Dict[K, V]:
        ...
    
    @overload
    def associate(self, transform: Callable[[T, int], Tuple[K, V]]) -> Dict[K, V]:
        ...
    
    @overload
    def associate(self, transform: Callable[[T, int, Sequence[T]], Tuple[K, V]]) -> Dict[K, V]:
        ...
    
    def associate(self, transform: Callable[..., Tuple[K, V]]) -> Dict[K, V]:
        """
        Returns a [Dict] containing key-value Tuple provided by [transform] function
        applied to elements of the given Sequence.

        Example 1:
        >>> lst = ['1', '2', '3']
        >>> it(lst).associate(lambda x: (int(x), x))
        {1: '1', 2: '2', 3: '3'}
        """
        ...
    
    @overload
    def associate_by(self, key_selector: Callable[[T], K]) -> Dict[K, T]:
        ...
    
    @overload
    def associate_by(self, key_selector: Callable[[T, int], K]) -> Dict[K, T]:
        ...
    
    @overload
    def associate_by(self, key_selector: Callable[[T, int, Sequence[T]], K]) -> Dict[K, T]:
        ...
    
    @overload
    def associate_by(self, key_selector: Callable[[T], K], value_transform: Callable[[T], V]) -> Dict[K, V]:
        ...
    
    def associate_by(self, key_selector: Callable[..., K], value_transform: Optional[Callable[[T], V]] = ...) -> Union[Dict[K, T], Dict[K, V]]:
        """
        Returns a [Dict] containing key-value Tuple provided by [transform] function
        applied to elements of the given Sequence.

        Example 1:
        >>> lst = ['1', '2', '3']
        >>> it(lst).associate_by(lambda x: int(x))
        {1: '1', 2: '2', 3: '3'}

        Example 2:
        >>> lst = ['1', '2', '3']
        >>> it(lst).associate_by(lambda x: int(x), lambda x: x+x)
        {1: '11', 2: '22', 3: '33'}

        """
        ...
    
    @overload
    def associate_by_to(self, destination: Dict[K, T], key_selector: Callable[[T], K]) -> Dict[K, T]:
        ...
    
    @overload
    def associate_by_to(self, destination: Dict[K, V], key_selector: Callable[[T], K], value_transform: Callable[[T], V]) -> Dict[K, V]:
        ...
    
    def associate_by_to(self, destination: Dict[K, Any], key_selector: Callable[[T], K], value_transform: Optional[Callable[[T], Any]] = ...) -> Dict[K, Any]:
        """
        Returns a [Dict] containing key-value Tuple provided by [transform] function
        applied to elements of the given Sequence.

        Example 1:
        >>> lst = ['1', '2', '3']
        >>> it(lst).associate_by_to({}, lambda x: int(x))
        {1: '1', 2: '2', 3: '3'}

        Example 2:
        >>> lst = ['1', '2', '3']
        >>> it(lst).associate_by_to({}, lambda x: int(x), lambda x: x+'!' )
        {1: '1!', 2: '2!', 3: '3!'}

        """
        ...
    
    @overload
    def all(self, predicate: Callable[[T], bool]) -> bool:
        ...
    
    @overload
    def all(self, predicate: Callable[[T, int], bool]) -> bool:
        ...
    
    @overload
    def all(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> bool:
        ...
    
    def all(self, predicate: Callable[..., bool]) -> bool:
        """
        Returns True if all elements of the Sequence satisfy the specified [predicate] function.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).all(lambda x: x > 0)
        True
        >>> it(lst).all(lambda x: x > 1)
        False
        """
        ...
    
    @overload
    def any(self, predicate: Callable[[T], bool]) -> bool:
        ...
    
    @overload
    def any(self, predicate: Callable[[T, int], bool]) -> bool:
        ...
    
    @overload
    def any(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> bool:
        ...
    
    def any(self, predicate: Callable[..., bool]) -> bool:
        """
        Returns True if any elements of the Sequence satisfy the specified [predicate] function.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).any(lambda x: x > 0)
        True
        >>> it(lst).any(lambda x: x > 3)
        False
        """
        ...
    
    @overload
    def count(self) -> int:
        ...
    
    @overload
    def count(self, predicate: Callable[[T], bool]) -> int:
        ...
    
    @overload
    def count(self, predicate: Callable[[T, int], bool]) -> int:
        ...
    
    @overload
    def count(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> int:
        ...
    
    def count(self, predicate: Optional[Callable[..., bool]] = ...) -> int:
        """
        Returns the number of elements in the Sequence that satisfy the specified [predicate] function.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).count()
        3
        >>> it(lst).count(lambda x: x > 0)
        3
        >>> it(lst).count(lambda x: x > 2)
        1
        """
        ...
    
    def contains(self, value: T) -> bool:
        """
        Returns True if the Sequence contains the specified [value].

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).contains(1)
        True
        >>> it(lst).contains(4)
        False
        """
        ...
    
    def element_at(self, index: int) -> T:
        """
        Returns the element at the specified [index] in the Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).element_at(1)
        2

        Example 2:
        >>> lst = [1, 2, 3]
        >>> it(lst).element_at(3)
        Traceback (most recent call last):
        ...
        IndexError: Index 3 out of range
        """
        ...
    
    @overload
    def element_at_or_else(self, index: int) -> Optional[T]:
        """
        Returns the element at the specified [index] in the Sequence or the [default] value if the index is out of bounds.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).element_at_or_else(1, 'default')
        2
        >>> it(lst).element_at_or_else(4, lambda x: 'default')
        'default'
        """
        ...
    
    @overload
    def element_at_or_else(self, index: int, default: T) -> T:
        ...
    
    @overload
    def element_at_or_else(self, index: int, default: Callable[[int], T]) -> T:
        ...
    
    def element_at_or_else(self, index: int, default: Union[Callable[[int], T], T, None] = ...) -> Optional[T]:
        """
        Returns the element at the specified [index] in the Sequence or the [default] value if the index is out of bounds.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).element_at_or_else(1, lambda x: 'default')
        2
        >>> it(lst).element_at_or_else(4, lambda x: 'default')
        'default'

        """
        ...
    
    def element_at_or_default(self, index: int, default: T) -> T:
        """
        Returns the element at the specified [index] in the Sequence or the [default] value if the index is out of bounds.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).element_at_or_default(1, 'default')
        2
        >>> it(lst).element_at_or_default(4, 'default')
        'default'

        """
        ...
    
    def element_at_or_none(self, index: int) -> Optional[T]:
        """
        Returns the element at the specified [index] in the Sequence or None if the index is out of bounds.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).element_at_or_none(1)
        2
        >>> it(lst).element_at_or_none(4) is None
        True
        """
        ...
    
    def distinct(self) -> Sequence[T]:
        """
        Returns a new Sequence containing the distinct elements of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3, 1, 2, 3]
        >>> it(lst).distinct().to_list()
        [1, 2, 3]

        Example 2:
        >>> lst = [(1, 'A'), (1, 'A'), (1, 'A'), (2, 'A'), (3, 'C'), (3, 'D')]
        >>> it(lst).distinct().sorted().to_list()
        [(1, 'A'), (2, 'A'), (3, 'C'), (3, 'D')]

        """
        ...
    
    @overload
    def distinct_by(self, key_selector: Callable[[T], Any]) -> Sequence[T]:
        ...
    
    @overload
    def distinct_by(self, key_selector: Callable[[T, int], Any]) -> Sequence[T]:
        ...
    
    @overload
    def distinct_by(self, key_selector: Callable[[T, int, Sequence[T]], Any]) -> Sequence[T]:
        ...
    
    def distinct_by(self, key_selector: Callable[..., Any]) -> Sequence[T]:
        """
        Returns a new Sequence containing the distinct elements of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3, 1, 2, 3]
        >>> it(lst).distinct_by(lambda x: x%2).to_list()
        [1, 2]
        """
        ...
    
    @overload
    def reduce(self, accumulator: Callable[[T, T], T]) -> T:
        ...
    
    @overload
    def reduce(self, accumulator: Callable[[U, T], U], initial: U) -> U:
        ...
    
    def reduce(self, accumulator: Callable[..., U], initial: Optional[U] = ...) -> Optional[U]:
        """
        Returns the result of applying the specified [accumulator] function to the given Sequence's elements.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).reduce(lambda x, y: x+y)
        6
        """
        ...
    
    def fold(self, initial: U, accumulator: Callable[[U, T], U]) -> U:
        """
        Returns the result of applying the specified [accumulator] function to the given Sequence's elements.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).fold(0, lambda x, y: x+y)
        6
        """
        ...
    
    @overload
    def sum_of(self, selector: Callable[[T], int]) -> int:
        ...
    
    @overload
    def sum_of(self, selector: Callable[[T], float]) -> float:
        ...
    
    def sum_of(self, selector: Callable[[T], Union[int, float]]) -> Union[int, float]:
        """
        Returns the sum of the elements of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).sum_of(lambda x: x)
        6
        """
        ...
    
    @overload
    def max_of(self, selector: Callable[[T], int]) -> int:
        ...
    
    @overload
    def max_of(self, selector: Callable[[T], float]) -> float:
        ...
    
    def max_of(self, selector: Callable[[T], Union[int, float]]) -> Union[int, float]:
        """
        Returns the maximum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).max_of(lambda x: x)
        3
        """
        ...
    
    @overload
    def max_by_or_none(self, selector: Callable[[T], int]) -> Optional[T]:
        ...
    
    @overload
    def max_by_or_none(self, selector: Callable[[T], float]) -> Optional[T]:
        ...
    
    def max_by_or_none(self, selector: Callable[[T], Union[float, int]]) -> Optional[T]:
        """
        Returns the first element yielding the largest value of the given function
        or `none` if there are no elements.

        Example 1:
        >>> lst = [ { "name": "A", "num": 100 }, { "name": "B", "num": 200 }]
        >>> it(lst).max_by_or_none(lambda x: x["num"])
        {'name': 'B', 'num': 200}

        Example 2:
        >>> lst = []
        >>> it(lst).max_by_or_none(lambda x: x["num"])
        """
        ...
    
    @overload
    def max_by(self, selector: Callable[[T], int]) -> T:
        ...
    
    @overload
    def max_by(self, selector: Callable[[T], float]) -> T:
        ...
    
    def max_by(self, selector: Callable[[T], Union[float, int]]) -> T:
        """
        Returns the first element yielding the largest value of the given function.

        Example 1:
        >>> lst = [ { "name": "A", "num": 100 }, { "name": "B", "num": 200 }]
        >>> it(lst).max_by(lambda x: x["num"])
        {'name': 'B', 'num': 200}

        Exmaple 2:
        >>> lst = []
        >>> it(lst).max_by(lambda x: x["num"])
        Traceback (most recent call last):
        ...
        ValueError: Sequence is empty.
        """
        ...
    
    @overload
    def min_of(self, selector: Callable[[T], int]) -> int:
        """
        Returns the minimum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).min_of(lambda x: x)
        1
        """
        ...
    
    @overload
    def min_of(self, selector: Callable[[T], float]) -> float:
        ...
    
    def min_of(self, selector: Callable[[T], Union[int, float]]) -> Union[int, float]:
        ...
    
    @overload
    def min_by_or_none(self, selector: Callable[[T], int]) -> Optional[T]:
        ...
    
    @overload
    def min_by_or_none(self, selector: Callable[[T], float]) -> Optional[T]:
        ...
    
    def min_by_or_none(self, selector: Callable[[T], float]) -> Optional[T]:
        """
        Returns the first element yielding the smallest value of the given function
        or `none` if there are no elements.

        Example 1:
        >>> lst = [ { "name": "A", "num": 100 }, { "name": "B", "num": 200 }]
        >>> it(lst).min_by_or_none(lambda x: x["num"])
        {'name': 'A', 'num': 100}

        Exmaple 2:
        >>> lst = []
        >>> it(lst).min_by_or_none(lambda x: x["num"])
        """
        ...
    
    @overload
    def min_by(self, selector: Callable[[T], int]) -> T:
        ...
    
    @overload
    def min_by(self, selector: Callable[[T], float]) -> T:
        ...
    
    def min_by(self, selector: Callable[[T], float]) -> T:
        """
        Returns the first element yielding the smallest value of the given function.

        Example 1:
        >>> lst = [ { "name": "A", "num": 100 }, { "name": "B", "num": 200 }]
        >>> it(lst).min_by(lambda x: x["num"])
        {'name': 'A', 'num': 100}

        Exmaple 2:
        >>> lst = []
        >>> it(lst).min_by(lambda x: x["num"])
        Traceback (most recent call last):
        ...
        ValueError: Sequence is empty.
        """
        ...
    
    def mean_of(self, selector: Callable[[T], Union[int, float]]) -> Union[int, float]:
        """
        Returns the mean of the elements of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).mean_of(lambda x: x)
        2.0
        """
        ...
    
    @overload
    def sum(self: Sequence[int]) -> int:
        """
        Returns the sum of the elements of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).sum()
        6
        """
        ...
    
    @overload
    def sum(self: Sequence[float]) -> float:
        ...
    
    def sum(self: Union[Sequence[int], Sequence[float]]) -> Union[float, int]:
        """
        Returns the sum of the elements of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).sum()
        6
        """
        ...
    
    @overload
    def max(self: Sequence[int]) -> int:
        ...
    
    @overload
    def max(self: Sequence[float]) -> float:
        ...
    
    def max(self: Union[Sequence[int], Sequence[float]]) -> Union[float, int]:
        """
        Returns the maximum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).max()
        3
        """
        ...
    
    @overload
    def max_or_default(self: Sequence[int]) -> int:
        ...
    
    @overload
    def max_or_default(self: Sequence[int], default: V) -> Union[int, V]:
        ...
    
    @overload
    def max_or_default(self: Sequence[float]) -> float:
        ...
    
    @overload
    def max_or_default(self: Sequence[float], default: V) -> Union[float, V]:
        ...
    
    def max_or_default(self: Union[Sequence[int], Sequence[float]], default: Optional[V] = ...) -> Union[float, int, V, None]:
        """
        Returns the maximum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).max_or_default()
        3

        Example 2:
        >>> lst = []
        >>> it(lst).max_or_default() is None
        True

        Example 3:
        >>> lst = []
        >>> it(lst).max_or_default(9)
        9
        """
        ...
    
    @overload
    def max_or_none(self: Sequence[int]) -> int:
        ...
    
    @overload
    def max_or_none(self: Sequence[float]) -> float:
        ...
    
    def max_or_none(self: Union[Sequence[int], Sequence[float]]) -> Union[float, int, None]:
        """
        Returns the maximum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).max_or_none()
        3

        Example 2:
        >>> lst = []
        >>> it(lst).max_or_none() is None
        True
        """
        ...
    
    @overload
    def min(self: Sequence[int]) -> int:
        """
        Returns the minimum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).min()
        1
        """
        ...
    
    @overload
    def min(self: Sequence[float]) -> float:
        ...
    
    def min(self: Union[Sequence[int], Sequence[float]]) -> Union[float, int]:
        """
        Returns the minimum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).min()
        1
        """
        ...
    
    @overload
    def min_or_none(self: Sequence[int]) -> Optional[int]:
        """
        Returns the minimum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).min_or_none()
        1
        """
        ...
    
    @overload
    def min_or_none(self: Sequence[float]) -> Optional[float]:
        ...
    
    def min_or_none(self: Union[Sequence[int], Sequence[float]]) -> Union[float, int, None]:
        """
        Returns the minimum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).min_or_none()
        1
        """
        ...
    
    @overload
    def min_or_default(self: Sequence[int]) -> int:
        """
        Returns the minimum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).min_or_default()
        1
        """
        ...
    
    @overload
    def min_or_default(self: Sequence[int], default: V) -> Union[int, V]:
        ...
    
    @overload
    def min_or_default(self: Sequence[float]) -> float:
        ...
    
    @overload
    def min_or_default(self: Sequence[float], default: V) -> Union[float, V]:
        ...
    
    def min_or_default(self: Union[Sequence[int], Sequence[float]], default: Optional[V] = ...) -> Union[float, int, V, None]:
        """
        Returns the minimum element of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).min_or_default()
        1

        Example 2:
        >>> lst = []
        >>> it(lst).min_or_default(9)
        9
        """
        ...
    
    @overload
    def mean(self: Sequence[int]) -> float:
        """
        Returns the mean of the elements of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).mean()
        2.0
        """
        ...
    
    @overload
    def mean(self: Sequence[float]) -> float:
        ...
    
    def mean(self: Union[Sequence[int], Sequence[float]]) -> float:
        """
        Returns the mean of the elements of the given Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst).mean()
        2.0
        """
        ...
    
    def reversed(self) -> Sequence[T]:
        """
        Returns a list with elements in reversed order.

        Example 1:
        >>> lst = ['b', 'c', 'a']
        >>> it(lst).reversed().to_list()
        ['a', 'c', 'b']
        """
        ...
    
    @overload
    def flat_map(self, transform: Callable[[T], Iterable[U]]) -> Sequence[U]:
        ...
    
    @overload
    def flat_map(self, transform: Callable[[T, int], Iterable[U]]) -> Sequence[U]:
        ...
    
    @overload
    def flat_map(self, transform: Callable[[T, int, Sequence[T]], Iterable[U]]) -> Sequence[U]:
        ...
    
    def flat_map(self, transform: Callable[..., Iterable[U]]) -> Sequence[U]:
        """
        Returns a single list of all elements yielded from results of [transform]
        function being invoked on each element of original collection.

        Example 1:
        >>> lst = [['a', 'b'], ['c'], ['d', 'e']]
        >>> it(lst).flat_map(lambda x: x).to_list()
        ['a', 'b', 'c', 'd', 'e']
        """
        ...
    
    def flatten(self: Iterable[Iterable[U]]) -> Sequence[U]:
        """
        Returns a sequence of all elements from all sequences in this sequence.

        Example 1:
        >>> lst = [['a', 'b'], ['c'], ['d', 'e']]
        >>> it(lst).flatten().to_list()
        ['a', 'b', 'c', 'd', 'e']
        """
        ...
    
    @overload
    def group_by(self, key_selector: Callable[[T], K]) -> Sequence[Grouping[K, T]]:
        ...
    
    @overload
    def group_by(self, key_selector: Callable[[T, int], K]) -> Sequence[Grouping[K, T]]:
        ...
    
    @overload
    def group_by(self, key_selector: Callable[[T, int, Sequence[T]], K]) -> Sequence[Grouping[K, T]]:
        ...
    
    def group_by(self, key_selector: Callable[..., K]) -> Sequence[Grouping[K, T]]:
        """
        Returns a dictionary with keys being the result of [key_selector] function being invoked on each element of original collection
        and values being the corresponding elements of original collection.

        Example 1:
        >>> lst = [1, 2, 3, 4, 5]
        >>> it(lst).group_by(lambda x: x%2).map(lambda x: (x.key, x.values.to_list())).to_list()
        [(1, [1, 3, 5]), (0, [2, 4])]
        """
        ...
    
    @overload
    def group_by_to(self, destination: Dict[K, List[T]], key_selector: Callable[[T], K]) -> Dict[K, List[T]]:
        ...
    
    @overload
    def group_by_to(self, destination: Dict[K, List[T]], key_selector: Callable[[T, int], K]) -> Dict[K, List[T]]:
        ...
    
    @overload
    def group_by_to(self, destination: Dict[K, List[T]], key_selector: Callable[[T, int, Sequence[T]], K]) -> Dict[K, List[T]]:
        ...
    
    def group_by_to(self, destination: Dict[K, List[T]], key_selector: Callable[..., K]) -> Dict[K, List[T]]:
        """
        Returns a dictionary with keys being the result of [key_selector] function being invoked on each element of original collection
        and values being the corresponding elements of original collection.

        Example 1:
        >>> lst = [1, 2, 3, 4, 5]
        >>> it(lst).group_by_to({}, lambda x: x%2)
        {1: [1, 3, 5], 0: [2, 4]}
        """
        ...
    
    @overload
    def for_each(self, action: Callable[[T], None]) -> None:
        ...
    
    @overload
    def for_each(self, action: Callable[[T, int], None]) -> None:
        ...
    
    @overload
    def for_each(self, action: Callable[[T, int, Sequence[T]], None]) -> None:
        ...
    
    def for_each(self, action: Callable[..., None]) -> None:
        """
        Invokes [action] function on each element of the given Sequence.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).for_each(lambda x: print(x))
        a
        b
        c

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).for_each(lambda x, i: print(x, i))
        a 0
        b 1
        c 2
        """
        ...
    
    @overload
    def parallel_for_each(self, action: Callable[[T], None], max_workers: Optional[int] = ...) -> None:
        ...
    
    @overload
    def parallel_for_each(self, action: Callable[[T, int], None], max_workers: Optional[int] = ...) -> None:
        ...
    
    @overload
    def parallel_for_each(self, action: Callable[[T, int, Sequence[T]], None], max_workers: Optional[int] = ...) -> None:
        ...
    
    def parallel_for_each(self, action: Callable[..., None], max_workers: Optional[int] = ...) -> None:
        """
        Invokes [action] function on each element of the given Sequence in parallel.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).parallel_for_each(lambda x: print(x))
        a
        b
        c

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).parallel_for_each(lambda x: print(x), max_workers=2)
        a
        b
        c
        """
        ...
    
    @overload
    def on_each(self, action: Callable[[T], None]) -> Sequence[T]:
        ...
    
    @overload
    def on_each(self, action: Callable[[T, int], None]) -> Sequence[T]:
        ...
    
    @overload
    def on_each(self, action: Callable[[T, int, Sequence[T]], None]) -> Sequence[T]:
        ...
    
    def on_each(self, action: Callable[..., None]) -> Sequence[T]:
        """
        Invokes [action] function on each element of the given Sequence.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).on_each(lambda x: print(x)) and None
        a
        b
        c

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).on_each(lambda x, i: print(x, i)) and None
        a 0
        b 1
        c 2
        """
        ...
    
    @overload
    def parallel_on_each(self, action: Callable[[T], None], max_workers: Optional[int] = ..., chunksize: int = ..., executor: ParallelMappingTransform.Executor = ...) -> Sequence[T]:
        ...
    
    @overload
    def parallel_on_each(self, action: Callable[[T, int], None], max_workers: Optional[int] = ..., chunksize: int = ..., executor: ParallelMappingTransform.Executor = ...) -> Sequence[T]:
        ...
    
    @overload
    def parallel_on_each(self, action: Callable[[T, int, Sequence[T]], None], max_workers: Optional[int] = ..., chunksize: int = ..., executor: ParallelMappingTransform.Executor = ...) -> Sequence[T]:
        ...
    
    def parallel_on_each(self, action: Callable[..., None], max_workers: Optional[int] = ..., chunksize: int = ..., executor: ParallelMappingTransform.Executor = ...) -> Sequence[T]:
        """
        Invokes [action] function on each element of the given Sequence.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).parallel_on_each(lambda x: print(x)) and None
        a
        b
        c

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).parallel_on_each(lambda x: print(x), max_workers=2) and None
        a
        b
        c
        """
        ...
    
    @overload
    def zip(self, other: Iterable[U]) -> Sequence[Tuple[T, U]]:
        ...
    
    @overload
    def zip(self, other: Iterable[U], transform: Callable[[T, U], V]) -> Sequence[V]:
        ...
    
    def zip(self, other: Iterable[Any], transform: Optional[Callable[..., V]] = ...) -> Sequence[Any]:
        """
        Returns a new Sequence of tuples, where each tuple contains two elements.

        Example 1:
        >>> lst1 = ['a', 'b', 'c']
        >>> lst2 = [1, 2, 3]
        >>> it(lst1).zip(lst2).to_list()
        [('a', 1), ('b', 2), ('c', 3)]

        Example 2:
        >>> lst1 = ['a', 'b', 'c']
        >>> lst2 = [1, 2, 3]
        >>> it(lst1).zip(lst2, lambda x, y: x + '__' +str( y)).to_list()
        ['a__1', 'b__2', 'c__3']
        """
        ...
    
    @overload
    def zip_with_next(self) -> Sequence[Tuple[T, T]]:
        ...
    
    @overload
    def zip_with_next(self, transform: Callable[[T, T], V]) -> Sequence[V]:
        ...
    
    def zip_with_next(self, transform: Optional[Callable[[T, T], Any]] = ...) -> Sequence[Any]:
        """
        Returns a sequence containing the results of applying the given [transform] function
        to an each pair of two adjacent elements in this sequence.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).zip_with_next(lambda x, y: x + '__' + y).to_list()
        ['a__b', 'b__c']

        Example 2:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).zip_with_next().to_list()
        [('a', 'b'), ('b', 'c')]
        """
        ...
    
    @overload
    def unzip(self: Sequence[Tuple[U, V]]) -> Tuple[ListLike[U], ListLike[V]]:
        ...
    
    @overload
    def unzip(self, transform: Callable[[T], Tuple[U, V]]) -> Tuple[ListLike[U], ListLike[V]]:
        ...
    
    @overload
    def unzip(self, transform: Callable[[T, int], Tuple[U, V]]) -> Tuple[ListLike[U], ListLike[V]]:
        ...
    
    @overload
    def unzip(self, transform: Callable[[T, int, Sequence[T]], Tuple[U, V]]) -> Tuple[ListLike[U], ListLike[V]]:
        ...
    
    def unzip(self: Sequence[Tuple[U, V]], transform: Union[Optional[Callable[..., Tuple[Any, Any]]], bool] = ...) -> Tuple[ListLike[U], ListLike[V]]:
        """
        Returns a pair of lists, where first list is built from the first values of each pair from this array, second list is built from the second values of each pair from this array.

        Example 1:
        >>> lst = [{'name': 'a', 'age': 11}, {'name': 'b', 'age': 12}, {'name': 'c', 'age': 13}]
        >>> a, b = it(lst).unzip(lambda x: (x['name'], x['age']))
        >>> a
        ['a', 'b', 'c']
        >>> b
        [11, 12, 13]

        Example 1:
        >>> lst = [('a', 11), ('b', 12), ('c', 13)]
        >>> a, b = it(lst).unzip()
        >>> a
        ['a', 'b', 'c']
        >>> b
        [11, 12, 13]
        """
        ...
    
    def with_index(self) -> Sequence[IndexedValue[T]]:
        """
        Returns a sequence containing the elements of this sequence and their indexes.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).with_index().to_list()
        [IndexedValue(0, a), IndexedValue(1, b), IndexedValue(2, c)]
        """
        ...
    
    @overload
    def shuffled(self) -> Sequence[T]:
        ...
    
    @overload
    def shuffled(self, seed: Union[int, float, str, bytes, bytearray, None]) -> Sequence[T]:
        ...
    
    @overload
    def shuffled(self, random: Random) -> Sequence[T]:
        ...
    
    def shuffled(self, seed: Union[Random, int, float, str, bytes, bytearray, None] = ...) -> Sequence[T]:
        """
        Returns a sequence that yields elements of this sequence randomly shuffled
        using the specified [random] instance as the source of randomness.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).shuffled('123').to_list()
        ['b', 'a', 'c']

        Example 2:
        >>> from random import Random
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).shuffled(Random('123')).to_list()
        ['b', 'a', 'c']

        Example 3:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).shuffled(123).to_list()
        ['c', 'b', 'a']
        """
        ...
    
    @overload
    def partition(self, predicate: Callable[[T], bool]) -> Tuple[ListLike[T], ListLike[T]]:
        ...
    
    @overload
    def partition(self, predicate: Callable[[T, int], bool]) -> Tuple[ListLike[T], ListLike[T]]:
        ...
    
    @overload
    def partition(self, predicate: Callable[[T, int, Sequence[T]], bool]) -> Tuple[ListLike[T], ListLike[T]]:
        ...
    
    def partition(self, predicate: Callable[..., bool]) -> Tuple[ListLike[T], ListLike[T]]:
        """
        Partitions the elements of the given Sequence into two groups,
        the first group containing the elements for which the predicate returns true,
        and the second containing the rest.

        Example 1:
        >>> lst = ['a', 'b', 'c', '2']
        >>> it(lst).partition(lambda x: x.isalpha())
        (['a', 'b', 'c'], ['2'])

        Example 2:
        >>> lst = ['a', 'b', 'c', '2']
        >>> it(lst).partition(lambda _, i: i % 2 == 0)
        (['a', 'c'], ['b', '2'])
        """
        ...
    
    def indexed(self) -> Sequence[IndexedValue[T]]:
        ...
    
    @overload
    def combinations(self, n: Literal[2]) -> Sequence[Tuple[T, T]]:
        ...
    
    @overload
    def combinations(self, n: Literal[3]) -> Sequence[Tuple[T, T, T]]:
        ...
    
    @overload
    def combinations(self, n: Literal[4]) -> Sequence[Tuple[T, T, T, T]]:
        ...
    
    @overload
    def combinations(self, n: Literal[5]) -> Sequence[Tuple[T, T, T, T, T]]:
        ...
    
    def combinations(self, n: int) -> Sequence[Tuple[T, ...]]:
        """
        Returns a Sequence of all possible combinations of size [n] from the given Sequence.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).combinations(2).to_list()
        [('a', 'b'), ('a', 'c'), ('b', 'c')]
        """
        ...
    
    def nth(self, n: int) -> T:
        """
        Returns the nth element of the given Sequence.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).nth(2)
        'c'
        """
        ...
    
    def windowed(self, size: int, step: int = ..., partialWindows: bool = ...) -> Sequence[List[T]]:
        """
         Returns a Sequence of all possible sliding windows of size [size] from the given Sequence.

        Example 1:
        >>> lst = ['a', 'b', 'c', 'd', 'e']
        >>> it(lst).windowed(3).to_list()
        [['a', 'b', 'c'], ['b', 'c', 'd'], ['c', 'd', 'e']]

        Example 2:
        >>> lst = ['a', 'b', 'c', 'd', 'e']
        >>> it(lst).windowed(3, 2).to_list()
        [['a', 'b', 'c'], ['c', 'd', 'e']]

        Example 3:
        >>> lst = ['a', 'b', 'c', 'd', 'e', 'f']
        >>> it(lst).windowed(3, 2, True).to_list()
        [['a', 'b', 'c'], ['c', 'd', 'e'], ['e', 'f']]
        """
        ...
    
    def chunked(self, size: int) -> Sequence[List[T]]:
        """
        Returns a Sequence of all possible chunks of size [size] from the given Sequence.

        Example 1:
        >>> lst = ['a', 'b', 'c', 'd', 'e']
        >>> it(lst).chunked(3).to_list()
        [['a', 'b', 'c'], ['d', 'e']]


        Example 2:
        >>> lst = ['a', 'b', 'c', 'd', 'e', 'f']
        >>> it(lst).chunked(3).to_list()
        [['a', 'b', 'c'], ['d', 'e', 'f']]
        """
        ...
    
    def repeat(self, n: int) -> Sequence[T]:
        """
        Returns a Sequence containing this sequence repeated n times.

        Example 1:
        >>> lst = ['a', 'b']
        >>> it(lst).repeat(3).to_list()
        ['a', 'b', 'a', 'b', 'a', 'b']
        """
        ...
    
    def concat(self, *other: Iterable[T]) -> Sequence[T]:
        """
        Returns a Sequence of all elements of the given Sequence, followed by all elements of the given Sequence.

        Example 1:
        >>> lst1 = ['a', 'b', 'c']
        >>> lst2 = [1, 2, 3]
        >>> it(lst1).concat(lst2).to_list()
        ['a', 'b', 'c', 1, 2, 3]

        Example 2:
        >>> lst1 = ['a', 'b', 'c']
        >>> lst2 = [1, 2, 3]
        >>> lst3 = [4, 5, 6]
        >>> it(lst1).concat(lst2, lst3).to_list()
        ['a', 'b', 'c', 1, 2, 3, 4, 5, 6]
        """
        ...
    
    def intersect(self, *other: Iterable[T]) -> Sequence[T]:
        """
        Returns a set containing all elements that are contained by both this collection and the specified collection.

        The returned set preserves the element iteration order of the original collection.

        To get a set containing all elements that are contained at least in one of these collections use union.

        Example 1:
        >>> lst1 = ['a', 'b', 'c']
        >>> lst2 = ['a2', 'b2', 'c']
        >>> it(lst1).intersect(lst2).to_list()
        ['c']

        Example 2:
        >>> lst1 = ['a', 'b', 'c']
        >>> lst2 = ['a2', 'b', 'c']
        >>> lst3 = ['a3', 'b', 'c3']
        >>> it(lst1).intersect(lst2, lst3).to_list()
        ['b']


        Example 1:
        >>> lst1 = ['a', 'a', 'c']
        >>> lst2 = ['a2', 'b2', 'a']
        >>> it(lst1).intersect(lst2).to_list()
        ['a']
        """
        ...
    
    def union(self, *other: Sequence[T]) -> Sequence[T]:
        """
        Returns a set containing all distinct elements from both collections.

        The returned set preserves the element iteration order of the original collection. Those elements of the other collection that are unique are iterated in the end in the order of the other collection.

        To get a set containing all elements that are contained in both collections use intersect.

        Example 1:
        >>> lst1 = ['a', 'b', 'c']
        >>> lst2 = ['a2', 'b2', 'c']
        >>> it(lst1).union(lst2).to_list()
        ['a', 'b', 'c', 'a2', 'b2']

        Example 2:
        >>> lst1 = ['a', 'b', 'c']
        >>> lst2 = ['a2', 'b', 'c']
        >>> lst3 = ['a3', 'b', 'c3']
        >>> it(lst1).union(lst2, lst3).to_list()
        ['a', 'b', 'c', 'a2', 'a3', 'c3']


        Example 1:
        >>> lst1 = ['a', 'a', 'c']
        >>> lst2 = ['a2', 'b2', 'a']
        >>> it(lst1).union(lst2).to_list()
        ['a', 'c', 'a2', 'b2']
        """
        ...
    
    def join(self: Sequence[str], separator: str = ...) -> str:
        """
        Joins the elements of the given Sequence into a string.

        Example 1:
        >>> lst = ['a', 'b', 'c']
        >>> it(lst).join(', ')
        'a, b, c'
        """
        ...
    
    @overload
    def progress(self) -> Sequence[T]:
        ...
    
    @overload
    def progress(self, progress_func: Union[Literal["tqdm"], Literal["tqdm_rich"]]) -> Sequence[T]:
        ...
    
    @overload
    def progress(self, progress_func: Callable[[Sequence[T]], Iterable[T]]) -> Sequence[T]:
        ...
    
    def progress(self, progress_func: Union[Callable[[Sequence[T]], Iterable[T]], Literal["tqdm"], Literal["tqdm_rich"], None,] = ...) -> Sequence[T]:
        """
        Returns a Sequence that enable a progress bar for the given Sequence.

        Example 1:
        >>> from tqdm import tqdm
        >>> from time import sleep
        >>> it(range(10)).progress(lambda x: tqdm(x, total=len(x))).parallel_map(lambda x: sleep(0.), max_workers=5).to_list() and None
        >>> for _ in it(list(range(10))).progress(lambda x: tqdm(x, total=len(x))).to_list(): pass
        """
        ...
    
    def typing_as(self, typ: Type[U]) -> Sequence[U]:
        """
        Cast the element as specific Type to gain code completion base on type annotations.
        """
        class AttrDict(Dict[str, Any]):
            ...
        
        
    
    def to_set(self) -> Set[T]:
        """
        Returns a set containing all elements of this Sequence.

        Example 1:
        >>> it(['a', 'b', 'c', 'c']).to_set() == {'a', 'b', 'c'}
        True
        """
        ...
    
    @overload
    def to_dict(self: Sequence[Tuple[K, V]]) -> Dict[K, V]:
        ...
    
    @overload
    def to_dict(self, transform: Callable[[T], Tuple[K, V]]) -> Dict[K, V]:
        ...
    
    @overload
    def to_dict(self, transform: Callable[[T, int], Tuple[K, V]]) -> Dict[K, V]:
        ...
    
    @overload
    def to_dict(self, transform: Callable[[T, int, Sequence[T]], Tuple[K, V]]) -> Dict[K, V]:
        ...
    
    def to_dict(self, transform: Optional[Callable[..., Tuple[K, V]]] = ...) -> Dict[K, V]:
        """
        Returns a [Dict] containing key-value Tuple provided by [transform] function
        applied to elements of the given Sequence.

        Example 1:
        >>> lst = ['1', '2', '3']
        >>> it(lst).to_dict(lambda x: (int(x), x))
        {1: '1', 2: '2', 3: '3'}

        Example 2:
        >>> lst = [(1, '1'), (2, '2'), (3, '3')]
        >>> it(lst).to_dict()
        {1: '1', 2: '2', 3: '3'}
        """
        ...
    
    def to_list(self) -> List[T]:
        """
        Returns a list with elements of the given Sequence.

        Example 1:
        >>> it(['b', 'c', 'a']).to_list()
        ['b', 'c', 'a']
        """
        ...
    
    async def to_list_async(self: Iterable[Awaitable[T]]) -> List[T]:
        """
        Returns a list with elements of the given Sequence.

        Example 1:
        >>> it(['b', 'c', 'a']).to_list()
        ['b', 'c', 'a']
        """
        ...
    
    def let(self, block: Callable[[Sequence[T]], U]) -> U:
        """
        Calls the specified function [block] with `self` value as its argument and returns its result.

        Example 1:
        >>> it(['a', 'b', 'c']).let(lambda x: x.map(lambda y: y + '!')).to_list()
        ['a!', 'b!', 'c!']
        """
        ...
    
    def also(self, block: Callable[[Sequence[T]], Any]) -> Sequence[T]:
        """
        Calls the specified function [block] with `self` value as its argument and returns `self` value.

        Example 1:
        >>> it(['a', 'b', 'c']).also(lambda x: x.map(lambda y: y + '!')).to_list()
        ['a', 'b', 'c']
        """
        ...
    
    @property
    def size(self) -> int:
        """
        Returns the size of the given Sequence.
        """
        ...
    
    def is_empty(self) -> bool:
        """
        Returns True if the Sequence is empty, False otherwise.

        Example 1:
        >>> it(['a', 'b', 'c']).is_empty()
        False

        Example 2:
        >>> it([None]).is_empty()
        False

        Example 3:
        >>> it([]).is_empty()
        True
        """
        ...
    
    def __iter__(self) -> Iterator[T]:
        ...
    
    def iter(self) -> Iterator[T]:
        ...
    
    def __do_iter__(self) -> Iterator[T]:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __bool__(self) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __getitem__(self, key: int) -> T:
        """
        Returns the element at the specified [index] in the Sequence.

        Example 1:
        >>> lst = [1, 2, 3]
        >>> it(lst)[1]
        2

        Example 2:
        >>> lst = [1, 2, 3]
        >>> it(lst)[3]
        Traceback (most recent call last):
        ...
        IndexError: Index 3 out of range
        """
        ...
    
    @overload
    def __callback_overload_warpper__(self, callback: Callable[[T], U]) -> Callable[[T], U]:
        ...
    
    @overload
    def __callback_overload_warpper__(self, callback: Callable[[T, int], U]) -> Callable[[T], U]:
        ...
    
    @overload
    def __callback_overload_warpper__(self, callback: Callable[[T, int, Sequence[T]], U]) -> Callable[[T], U]:
        ...
    
    def __callback_overload_warpper__(self, callback: Callable[..., U]) -> Callable[[T], U]:
        ...
    


class AutoIncrementIndex:
    idx = ...
    def __call__(self) -> int:
        ...
    


class IndexedValue(NamedTuple, Generic[T]):
    val: T
    idx: int
    def __repr__(self) -> str:
        ...
    


def throw(exception: Exception) -> Any:
    ...

def none_or(value: Optional[T], default: T) -> T:
    ...

def none_or_else(value: Optional[T], f: Callable[[], T]) -> T:
    ...

def is_debugging() -> bool:
    ...

class SequenceProducer:
    @overload
    def __call__(self, elements: List[T]) -> Sequence[T]:
        ...
    
    @overload
    def __call__(self, elements: Iterable[T]) -> Sequence[T]:
        ...
    
    @overload
    def __call__(self, *elements: T) -> Sequence[T]:
        ...
    
    def __call__(self, *iterable: Union[Iterable[T], List[T], T]) -> Sequence[T]:
        ...
    
    def json(self, filepath: str, **kwargs: Dict[str, Any]) -> Sequence[Any]:
        """
        Reads and parses the input of a json file.
        """
        ...
    
    def csv(self, filepath: str) -> Sequence[List[str]] | Sequence[Dict[str, str]]:
        """
        Reads and parses the input of a csv file.
        """
        ...
    
    def read_csv(self, filepath: str, header: Optional[int] = ...) -> Sequence[List[str]] | Sequence[Dict[str, str]]:
        """
        Reads and parses the input of a csv file.

        Example 1:
        >>> it.read_csv('tests/data/a.csv').to_list()
        [{'a': 'a1', 'b': '1'}, {'a': 'a2', 'b': '2'}]
        """
        ...
    
    def __repr__(self) -> str:
        ...
    


sequence: SequenceProducer = ...
seq: SequenceProducer = ...
it: SequenceProducer = ...
if __name__ == "__main__":
    ...
